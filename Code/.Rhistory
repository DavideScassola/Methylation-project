pre_binned <- hist(positions,breaks = l/(pre_binning), plot = F)$counts
bin_sizes <- good_bin_sizes(length(pre_binned), max_bins)
if(verbose) cat("Calculating cumulative sum vector \n")
cumulative_sum_vector <- corrected_cumsum(pre_binned)
out <- (sapply(bin_sizes, function(x)
{
if(verbose) cat(x, "...\n")
calculate_relevance_and_resolution_ignoring_nas(pre_binned, cumulative_sum_vector, bin_size = x)
}))
end_time <- Sys.time()
if(verbose) print(end_time-start_time)
return(out)
}
genome_MSR <- function(methylation_positions, minimum_bin_size = 10, verbose = T, invert = F)
{
v = methylation_positions - min(methylation_positions) + 1
v = sparseVector(i = v, x = T, length = max(v))
rr <- calculate_relevance_resolution_vector_ignoring_nas(v, minimum_bin_size = minimum_bin_size, invert = invert, verbose = verbose)
return(rr)
}
# supposing resolution is in decresing order
MSR_area<- function(rr_vector, M_correction = 10)
{
return(trapz(x = rev(rr_vector[2,]), y = rev(rr_vector[1,]))*log10(M_correction))
}
calculate_MSR_area<- function(v)
{
rr <- calculate_relevance_resolution_vector_ignoring_nas(v, verbose = F)
M <- sum(rr)
MSR_area(rr, M)
}
############################### PLOT FUNCTIONS ###############################
resolution_relevance_plot <- function(relevance_resolution_vector)
{
plot(x = relevance_resolution_vector[2,], y = relevance_resolution_vector[1,], type = "l")
}
bin_size_relevance_plot <- function(relevance_resolution_vector)
{
plot(x = relevance_resolution_vector[3,], y = relevance_resolution_vector[1,], type = "l", log = "x")
}
bin_size_resolution_plot <- function(relevance_resolution_vector)
{
plot(x = relevance_resolution_vector[3,], y = relevance_resolution_vector[2,], type = "l", log = "x")
}
compare_resolution_relevance_plot <- function(relevance_resolution_vector_list, legend_names, title)
{
plot(x = (relevance_resolution_vector_list[[1]])[2,], y = (relevance_resolution_vector_list[[1]])[1,], type = "l", col = 1, xlab = "resolution", ylab = "relevance", ylim = c(0,0.5), xlim = c(0,1))
grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted")
n <- length(relevance_resolution_vector_list)
if(n>1)
{
for(i in 2:n)
{
lines(x = (relevance_resolution_vector_list[[i]])[2,], y = (relevance_resolution_vector_list[[i]])[1,], type = "l", col = i)
}
}
title(title)
legend("topleft", legend=legend_names, col=1:n, lty = 1, cex = 0.7, y.intersp = 0.5)
}
compare_bin_size_relevance_plot <- function(bsrvl, legend_names, title)
{
l <- length(bsrvl[[1]][1,])
n <- length(bsrvl)
grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted")
plot(x = (bsrvl[[1]])[3,], y = (bsrvl[[1]])[1,], type = "p", col = 1, xlab = "bin_size", ylab = "relevance", ylim = c(0,0.6), log = "x")
lines(x = (bsrvl[[1]])[3,], y = (bsrvl[[1]])[4,], type = "l", col = 1)
if(n>1)
{
for(i in 2:n)
{
lines(x = (bsrvl[[i]])[3,], y = (bsrvl[[i]])[1,], type = "p", col = i)
lines(x = (bsrvl[[i]])[3,], y = (bsrvl[[i]])[4,], type = "l", col = i)
}
}
title(title)
legend("topright", legend=legend_names, col=1:n, lty = 1, cex = 0.8, y.intersp = 0.8)
}
compare_bin_size_resolution_plot <- function(bsrvl, legend_names, title)
{
l <- length(bsrvl[[1]][2,])
n <- length(bsrvl)
grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted")
plot(x = (bsrvl[[1]])[3,], y = (bsrvl[[1]])[2,], type = "p", col = 1, xlab = "bin_size", ylab = "resolution", ylim = c(0,1), xlim = c(1, l*100000), log = "x")
lines(x = (bsrvl[[1]])[3,], y = (bsrvl[[1]])[4,], type = "l", col = 1)
if(n>1)
{
for(i in 2:n)
{
lines(x = (bsrvl[[i]])[3,], y = (bsrvl[[i]])[2,], type = "p", col = i)
lines(x = (bsrvl[[i]])[3,], y = (bsrvl[[i]])[4,], type = "l", col = i)
}
}
title(title)
legend("topright", legend=legend_names, col=1:n, lty = 1, cex = 0.8, y.intersp = 0.8)
}
compare_resolution_relevance_plot_confidence <- function(relevance_resolution_vector_list, legend_names, title)
{
grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted")
plot(x = (relevance_resolution_vector_list[[1]])[2,], y = (relevance_resolution_vector_list[[1]])[1,], type = "p", col = 1, xlab = "resolution", ylab = "relevance", ylim = c(0,0.8))
lines(x = (relevance_resolution_vector_list[[1]])[2,], y = (relevance_resolution_vector_list[[1]])[4,], type = "h", col = 1)
n <- length(relevance_resolution_vector_list)
if(n>1)
{
for(i in 2:n)
{
lines(x = (relevance_resolution_vector_list[[i]])[2,], y = (relevance_resolution_vector_list[[i]])[1,], type = "p", col = i)
lines(x = (relevance_resolution_vector_list[[i]])[2,], y = (relevance_resolution_vector_list[[i]])[4,], type = "h", col = i)
}
}
title(title)
legend("topleft", legend=legend_names, col=1:n, lty = 1, cex = 0.8, y.intersp = 0.8)
}
remove_low_confidence_points <- function(rr_vector, threshold = 0.01)
{
return(rr_vector[,rr_vector[4,]>=threshold])
}
remove_low_confidence_points_list <- function(rr_vector_list, threshold = 0.01)
{
return(lapply(rr_vector_list, function(x) { return(remove_low_confidence_points(x, threshold))}))
}
rr_plots <- function(rr_list, title = "", legend_names = "", threshold = 0.05)
{
compare_resolution_relevance_plot(rr_list, legend_names, title)
par(ask=TRUE)
compare_resolution_relevance_plot_confidence(rr_list, legend_names, title)
compare_resolution_relevance_plot(remove_low_confidence_points_list(rr_list, threshold = threshold), legend_names = legend_names, title = paste(title, "\n removing points using less than ", threshold*100, "% effective data", sep = ""))
compare_bin_size_relevance_plot(rr_list, legend_names, title)
compare_bin_size_resolution_plot(rr_list, legend_names, title)
par(ask=FALSE)
}
############################### AUX FUNCTIONS ###############################
get_max_information_vector <- function(size)
{
probs = rep_len(0, size)
n = floor(sqrt(size))
for(i in 1:n)
{
probs[(1+((i-1)*n)):(i*n)] = 1/i
}
return(rbinom(n = size, size = 1, prob = probs))
}
mutilated <- function(v, missing_proportion)
{
l <- length(v)
mask <- as.logical(rbinom(l, size = 1, prob = missing_proportion))
m <- v
m[mask] = NA
return(m)
}
nameof <- function(v1) {
deparse(substitute(v1))
}
missing_data_experiment <- function(full_vector, missing_data_rates = c(0,0.1,0.2,0.5,0.7,0.9), max_bins = 100, no_data_out = F, na_values_handler, info = "", na_tolerance = 0)
{
cat("missing_data_rates: ", missing_data_rates, "\n")
vectors <- lapply(missing_data_rates, function(r) mutilated(full_vector, r))
rr_missings = mclapply(vectors, function(v) calculate_relevance_resolution_vector(v,na_tolerance = na_tolerance, max_bins = max_bins, no_data_out = no_data_out, na_values_handler = na_values_handler), mc.cores = 1)
legend_names <- paste(missing_data_rates*100, "% miss.", sep = "")
rr_plots(rr_missings, title = info, legend_names = legend_names)
return(list(rr_data = rr_missings, missing_rates = missing_data_rates, na_tolerance = na_tolerance, max_bins = max_bins, info = info))
}
apply_same_missing_data_pattern <- function(vector, mask_vector)
{
v <- vector
v[is.na(mask_vector)] = NA
return(v)
}
##############################################################################
suppressMessages(library(Matrix))
suppressMessages(library(BSgenome.Mmusculus.UCSC.mm10))
suppressMessages(library(BSgenome.Hsapiens.UCSC.hg38))
suppressMessages(require(Biostrings))
#load("DataCleaning/CpG_sites_dataframe.RData")
nucleotides_pattern_positions <- function(chromosome, pattern, Genome = BSgenome.Mmusculus.UCSC.mm10)
{
ranges <- matchPattern(pattern,(Genome[[chromosome]]))
return(IRanges(ranges)@start)
}
binary_nucleotides_pattern_positions <- function(chromosome, pattern, Genome = BSgenome.Mmusculus.UCSC.mm10)
{
positions <- IRanges(matchPattern(pattern,(Genome[[chromosome]])))@start
chromosome_size <- length(Genome[[chromosome]])
return(sparseVector(i = positions, length = chromosome_size, x = T))
}
mouse_dinucleotides_experiment <- function(pattern_list, chromosome)
{
rr_list <- lapply(pattern_list, function(p) {
chr_p <- binary_nucleotides_pattern_positions(chromosome,p)
rr_chr_p <- calculate_relevance_resolution_vector_ignoring_nas(chr_p)
remove(chr_p)
gc()
return(rr_chr_p)
})
gc()
areas <- array(length(rr_list))
for(i in 1:length(rr_list))
{
areas[i] <- MSR_area(rr_list[[i]], M_correction = sum(binary_nucleotides_pattern_positions(chromosome,pattern_list[i])))
}
cat("\nMSR corrected areas: ", areas)
rr_plots(rr_list, title = "dinucleotides_MSR_comparison", legend_names = pattern_list)
return((List(rr = rr_list, areas = areas)))
}
#############################################################################
subset_positions <- function(pos, start, size) { pos[pos>=start & pos<=(start+size)] }
pos_to_neighbor_counts  <- function(pos, dinucleotides_neighborhood_ranges, centered = T)
{
max_half = max(dinucleotides_neighborhood_ranges)/2
v = (pos - min(pos) + 1)+max_half
v2 = sparseVector(i = v, x = T, length = max(v)+max_half)
cumulative_sum_vector <- corrected_cumsum(v2)
#cat("\ncumulative_sum_vector: ", cumulative_sum_vector)
#cat("\npos: ", pos, "\n")
#cat("v: ", v, "\n")
result = sapply(dinucleotides_neighborhood_ranges, function(r)
{
cumulative_sum_vector[v+r/2]-cumulative_sum_vector[v-r/2]
})
remove(cumulative_sum_vector)
colnames(result) <- (dinucleotides_neighborhood_ranges)
gc()
return(as.data.frame(result))
#sum(pos<pos+half & pos>pos-half)
}
filter_odd_position_values <- function(v)
{
v[2*(0:(ceiling(length(v)/2)-1))+1]
}
get_CpG_densities <- function(dinucleotides_neighborhood_ranges, Genome = BSgenome.Hsapiens.UCSC.hg38, data = NA)
{
chr_list = chromosomes(Genome = BSgenome.Hsapiens.UCSC.hg38)
n = length(chr_list)
CpGlists <- lapply(chr_list, function(chr)
{
cat("processing ", chr, "\n")
if(type(data)=="logical")
pos <- nucleotides_pattern_positions(chr, "CG", Genome = Genome)
else
pos <- filter_odd_position_values(filter_chromosome(data,chr)$Cpos)
gc()
pos_to_neighbor_counts(pos, dinucleotides_neighborhood_ranges)
})
gc()
result <- data.frame()
for(p in CpGlists)
{
result = rbind(result,p)
}
return(result)
}
autocor <- function(v, lag)
{
l = length(v)
plot(v[1:(l-lag)],v[(1+lag):l])
cor.test(v[1:(l-lag)],v[(1+lag):l])
}
autotable <- function(v, lag)
{
l = length(v)
table(v[1:(l-lag)],v[(1+lag):l])
}
random_binary_vector <- function(l, prop)
{
M <- round(l*prop)
bin <- array(dim = l, 0)
bin[sample(1:l, M)] <- 1
return((bin))
}
sample_msr <- function(l, prop)
{
v <- random_binary_vector(l, prop)
rr_v <- calculate_relevance_resolution_vector_ignoring_nas(v, verbose = F)
MSR_area(rr_v)
}
msr_samples <- function(l, prop, sample_size, cores = 1, verbose = F)
{
start_time <- Sys.time()
msr_samples = mcmapply(1:sample_size, mc.preschedule = T, mc.cores = cores, FUN =  function(n)
{
#if(verbose) cat(n, " ")
sample_msr(l, prop)
})
if(verbose) cat("time: ", Sys.time()-start_time)
return(msr_samples)
}
msr_significance_experiment <- function(l,prop_list, samples_size, cores = 1, verbose = F)
{
start_time <- Sys.time()
exp = mcmapply(prop_list, mc.preschedule = T, mc.cores = cores, FUN =  function(p)
{
if(verbose) cat(p, " ")
msr_samples(l, p, samples_size, cores = 1, verbose = F)
})
cat("time: ", Sys.time()-start_time)
exp = t(exp)
rownames(exp) <- prop_list
return(List(data=exp, prop_list=prop_list))
}
get_msr_ecdf <- function(l, prop, sample_size, cores = 1)
{
return(ecdf(msr_samples(l, prop, sample_size, verbose = F, cores = cores)))
}
get_msr_ecdfs <- function(l, prop_list, sample_size, cores = 1)
{
sapply(prop_list, function(prop)
{
if(prop==0 || prop==1) e = NA
else e = get_msr_ecdf(l, prop, sample_size, cores = cores)
return(List(cdf = e, prop=prop))
})
}
inverse = function(f, lower = -100, upper = 100) {
function (y) uniroot((function (x) f(x) - y), lower = lower, upper = upper)[1]$root
}
msr_confidence_line <- function(ecdfs, confidence = 0.99)
{
sapply(ecdfs, function(f)
{
if( f$prop==0 || f$prop==1) return(c(f$prop,NA))
c(f$prop, inverse(f$cdf, 0, 0.4)(confidence))
})
}
add_msr_confidence_line <- function(ecdfs, confidence = 0.99, col = 1, lty = 2)
{
conf = msr_confidence_line(ecdfs, confidence)
lines(conf[1,], conf[2,], col=col, lty=lty)
}
general_msr_cdf <- function(ecdfs, density, msr)
{
for( i in 1:length(ecdfs))
{
if(density>= ecdfs[[i]]$prop & density<= ecdfs[[i+1]]$prop)
{
dist1 = density - ecdfs[[i]]$prop
dist2 = ecdfs[[i+1]]$prop - density
w = dist1/(dist1+dist2)
return(ecdfs[[i]]$cdf(msr)*(1-w)+(w)*ecdfs[[i+1]]$cdf(msr))
}
}
}
markovchain_fake_data <- function(size, transition_matrix)
{
model <- new("markovchain", states = c("0","1"), transitionMatrix = transition_matrix)
as.integer(rmarkovchain(size, object = meth_model, t0 = "0"))
}
prop_msr_samples(l, props, sample_size = 100)
order(c(1,2,3,4))
order(c(1,2,3,4,5))
MSR_area<- function(rr_vector)
{
ord = order(rr_vector[1,])
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
h1 = msr_samples(1000, 0.2, 1000)
calculate_relevance_resolution_vector_ignoring_nas <- function(methylation_vector, max_bins = 100, verbose = T, minimum_bin_size = 1, invert = F)
{
if(invert) methylation_vector <- !methylation_vector
start_time <- Sys.time()
l <- length(methylation_vector)
bin_sizes <- good_bin_sizes(l, max_bins)
bin_sizes <- bin_sizes[(bin_sizes>minimum_bin_size) | (bin_sizes==1) ]
nas <- is.na(methylation_vector)
replaced_nas_vector <- methylation_vector
replaced_nas_vector[nas] <- 0
if(verbose) cat("Calculating cumulative sum vector \n")
cumulative_sum_vector <- corrected_cumsum(replaced_nas_vector)
#################################
# I don't want my RAM to explode
remove(replaced_nas_vector, nas)
if(l>1e7) gc()
#################################
out <- (sapply(bin_sizes, function(x)
{
if(verbose) cat(x, "...\n")
calculate_relevance_and_resolution_ignoring_nas(methylation_vector, cumulative_sum_vector, bin_size = x)
}))
end_time <- Sys.time()
if(verbose) print(end_time-start_time)
return(out)
}
h1 = msr_samples(1000, 0.2, 1000)
hist(h1)
# supposing resolution is in decreasing order
MSR_area<- function(rr_vector, M_correction = 10)
{
return(trapz(x = rev(rr_vector[2,]), y = rev(rr_vector[1,]))*log10(M_correction))
}
h1 = msr_samples(1000, 0.2, 1000)
hist(h1)
msr_samples(1000, 0.2, 1)
calculate_MSR_area<- function(v)
{
rr <- calculate_relevance_resolution_vector_ignoring_nas(v, verbose = F)
M <- sum(rr)
MSR_area(rr, M)
}
MSR_area<- function(rr_vector)
{
ord = order(rr_vector[1,])
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
msr_samples(1000, 0.2, 1)
msr_samples(1000, 0.2, 1)
msr_samples(1000, 0.2, 1)
msr_samples(1000, 0.2, 1)
MSR_area<- function(rr_vector)
{
cat(rr_vector[1,])
ord = order(rr_vector[1,])
cat(ord)
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
msr_samples(1000, 0.2, 1)
msr_samples(10000, 0.2, 1)
MSR_area<- function(rr_vector)
{
cat(rr_vector[2,])
#ord = order(rr_vector[2,])
cat(ord)
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
msr_samples(1000, 0.2, 1)
MSR_area<- function(rr_vector)
{
cat(rr_vector[2,])
ord = order(rr_vector[2,])
cat(ord)
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
msr_samples(1000, 0.2, 1)
MSR_area<- function(rr_vector)
{
ord = order(rr_vector[2,])
return(trapz(x = rr_vector[2,][ord], y = rr_vector[1,][ord] ))
}
msr_samples(1000, 0.2, 1)
h1 = msr_samples(1000, 0.2, 1000)
hist(h1)
# supposing resolution is in decreasing order
MSR_area<- function(rr_vector, M_correction = 10)
{
return(trapz(x = rev(rr_vector[2,]), y = rev(rr_vector[1,]))*log10(M_correction))
}
h2 = msr_samples(1000, 0.2, 1000)
hist(h2)
hist(h1)
hist(h2)
hist(h1, add = T)
prop_msr_samples(l, props, sample_size = 1000)
prop_msr_samples <- function(l, props, sample_size, cores = 1, verbose = F)
{
start_time <- Sys.time()
msr_samples = mcmapply(1:sample_size, mc.preschedule = T, mc.cores = cores, FUN =  function(n)
{
v = rbinom(n = l, size = 1, prob = probs)
rr_v <- calculate_relevance_resolution_vector(methylation_vector = v)
MSR_area(rr_v)
})
if(verbose) cat("time: ", Sys.time()-start_time)
return(msr_samples)
}
a = prop_msr_samples(l, props, sample_size = 1000)
prop_msr_samples <- function(l, props, sample_size, cores = 1, verbose = F)
{
start_time <- Sys.time()
msr_samples = mcmapply(1:sample_size, mc.preschedule = T, mc.cores = cores, FUN =  function(n)
{
v = rbinom(n = l, size = 1, prob = probs)
rr_v <- calculate_relevance_resolution_vector(methylation_vector = v, verbose = F)
MSR_area(rr_v)
})
if(verbose) cat("time: ", Sys.time()-start_time)
return(msr_samples)
}
a = prop_msr_samples(l, props, sample_size = 1000)
hist(a)
a
v = rbinom(n = l, size = 1, prob = probs)
v
calculate_relevance_resolution_vector(v)
MSR_area(calculate_relevance_resolution_vector(v))
MSR_area(calculate_relevance_resolution_vector(v))
prop_msr_samples <- function(l, props, sample_size, cores = 1, verbose = F)
{
start_time <- Sys.time()
msr_samples = mcmapply(1:sample_size, mc.preschedule = T, mc.cores = cores, FUN =  function(n)
{
v = rbinom(n = l, size = 1, prob = probs)
rr_v <- calculate_relevance_resolution_vector(methylation_vector = v, verbose = F, na_tolerance = 0.1)
MSR_area(rr_v)
})
if(verbose) cat("time: ", Sys.time()-start_time)
return(msr_samples)
}
a = prop_msr_samples(l, props, sample_size = 1000)
a
print(a)
hist(a)
std(a)
mean(a)
probs = data_H1[(1e4):(1e4+1e4)]$prop/100
a = prop_msr_samples(l, props, sample_size = 100)
mean(a)
std(a)
hist(a)
probs = data_H1[(1e4):(1e4+1e5)]$prop/100
a = prop_msr_samples(l, props, sample_size = 10)
hist(a)
probs = data_H1[(10e4):(10e4+1e3)]$prop/100
a = prop_msr_samples(l, props, sample_size = 10)
hist(prop_msr_samples(l, props, sample_size = 1000))
hist(probs)
